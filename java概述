===========================================================================================================================================
1.认识java（起源于SUN后被Orecle收购）
    java是一门面向对象的编程语言，吸收了c++语言的优点，并摒弃了其多继承、指针等概念。是简单易用的面向对象编程语言。
    java开发分为以下3个方向，javaSE（java platform standard edition）标准版，是javaEE和javaME的基础，包括各种java语言核心类。
 javaEE（java platform enterprise edition）企业版，用于web开发，包含servlet、jsp、xml、事物控制等，是现在java应用的主要方向。javaME（java platform micro edition）小型版，用于嵌入式系统程序的开发，用于智能手机、手机、机顶盒等电子产品软件的开发。（Android SDK是统一性更好，不需要为每台设备配置javaME运行环境）
  
    1995年SUN公司推出java语言，因为其可以解决动态web，而被大量程序员追捧。如今已经历时23年。
    
    java语言特点：
       java语言是简单的：不使用指针，提供自动的垃圾回收机制，使程序员不必担心内存管理问题。
       java语言面向对象：类只支持单继承，但可实现多个接口。
       java语言是分布式的：因其有强大易用的联网能力，即网络应用编程接口（java.net）
       java语言是健壮的：强类型机制、异常处理、垃圾自动收集等特性。丢弃指针和使用安全检查机制使得java更加robust。
       java语言是安全的：安全防范机制，安全检查机制。
       java语言是可移植的：不同平台配备不同版本的jvm，一次编译到处运行，javac.exe是java实现的，java.exe是ANSI C实现的。
       java语言是解释型的：java字节码由jvm解释执行。
       java语言是高性能的：java的运行速度随着JIT编译技术（此处编译值jvm中解释执行前会检测编译部分热点字节码）的发展越来越接近c++。
       java语言是多线程的：很多操作系统将线程视为基本的执行单位，语言支持多行程机制，为开发者带来方便。
       java语言是动态的：适应动态变化的环境，可将新代码加入一个正在运行的程序中。
       
     jdk下载（Oracle官网），配置环境变量JAVA_HOME,并将其加入系统路径Path中，cmd中执行javac或java -version测试环境是否配置好。
     jdk目录介绍：bin（javac.exe、java.exe、jar.exe、jdb.exe、javadoc.exe文档生成工具）
                 db（javaDB）
                 include（启动jdk是需要引入的C语言头文件）
                 jre（jvm、运行时类包等）
                 lib（存放java类库或库文件）
                 javafx-src.zip（java FX所有核心类库的源代码、GUI开发库（swing、SWT、java FX））
                 src.zip（java所有核心类库的源代码）
                 README和LICENSE（说明性文档）
            
     hello world编写过程：1.新建.txt文件,并重命名为类名称的java文件（ByYourself.java）,编写各种class，。2.进入cmd操作界面，d:盘符选择命令、cd 文                         件名进入该文件存放处。3.执行javac进行编译（javac HelloWorld.java），此时同文件下会生成对应类的class文件。4.java文件执行
                        （java 各种class（想运行必须加入main函数入口，否则虽通过编译运行会报错）），直接加类名就行不需带文件名。
                 
                 注意：ByYourself.java文件中，可以有多个类，最终被编译为多个class文件。
     
=========================================================================================================================================

2.java编程基础
     代码块：java中使用{}将语句编组，组中的语句称为代码块。
     注释：只在java源文件中有效，编译时会忽略，不会编译到class文件中去，也因此可以注释某些语句进行调试。
         单行注释：语句前加 //
         多行注释： /* ....  */
         文档注释： /**...   */  对一段代码概括的解释说明，可使用javadoc命令将注释内容提取成正式的帮助文档。
         
         多行注释中可包含单行注释。
     关键字：goto 和 const关键字还未开发称为保留字。 true、false、null是量，不属于关键字，也不能随意乱用。
     进制转换：2进制--10进制：2的几次方。
              10进制--2进制：整数（除2逆序取余）小数（乘2顺序取整）
              2进制--8进制：3位变1位。
              8进制--2进制：1位变3位。
              2进制--16进制：4位变1位。
              16进制--2进制：1位变4位。（从末尾开始不足补0）
     基本数据类型（8种）：整数类型(byte【-2^7,2^7-1】、short【-2^15,2^15-1】、int【-2^31,2^31-1】、long【-2^63,2^63-1】) （1、2、4、8）
              java中直接给出整数类型值默认为int， byte n=100；自动将int类型100当成byte类型处理。
                                           long m=99999；可加L可不加L。long m=9999999999L;超出int取值范围，必须加L后缀。
              浮点类型（float【-3.4*10^38,3.4*10^38】、double【-1.79*10^308,1.79*10^308】）（4、8）
              java中直接给出的浮点型默认为double，double n=10.0；
                                        float x=10.0；将丢失精度赋值错误。
                                        float y=10.0f；
              字符类型（char【0,2^16-1】）java语言采用16的Unicode字符编码集，Unicode为每个字符对应一个统一且唯一的数值，Unicode支持中文字符。
              布尔类型（boolean【true or false】
                                          boolean b=1；不能用非零代表真 错误。
                                          Boolean b=0；不能用零代表假 错误。
      常量：常量的书写规范所有字母都大写，如果由多个单词组成，单词间通过_连接。
      变量名命名规则（常量，变量，包，类，方法）：（1）必须是由字母、数字、下划线_、美元符号“$”组成的字符序列。
                                              （2）不能以数字开头，其他均可。
                                              （3）不能是关键字或保留字。
                                              （4）不能包含空格。（不遵守以上规则，编译通不过）
      变量：申明后，会告诉编译器开辟怎样的内存，并用变量名来方便操作，可以赋值可以不赋值。
             int n=0，q=1；
             double x，y，z；
      变量类型转换：
           （1）自动类型转换：也叫隐式类型转换，条件成立时，自动进行转换。（1）转换的两种数据类型彼此兼容。（2）目标数据类型的取值范围比原类型大。
                            类型转换只限该行语句。任何基本类型的值和字符串进行运算“+”时，都将自动类型转换为字符串类型。
                            8字节long会隐式转换为4字节float自行百度。
           （2）强制类型转换：也叫显示类型转换。不满足上述两点规则时，需强转。byte a=（byte）128；将3个高位字节丢弃，导致a=-128。
      变量的作用域：是指它的作用范围，变量声明一定会在一对大括号中，该大括号所包含的代码区域就是这个变量的作用域。
      常量：
           整型：
           二进制 0b110 0B110【0/1】
           八进制 0110【0/7】
           十进制 110【0/9】
           十六进制 0x12 0XAbA【0/9 A/F】
           浮点型：
           1.5f 1.5F 1.5d 1.5D【默认】
           5E-8 1.2e+6
           字符型：
           'a'  '0'  
           '\n'  '\t'  '\0' 转义字符
           '\u0000'       u+ Unicode16位值  表示的字符
           字符串：
           "A"  "java"
           布尔：
           true  false
           null常量：
           null  表示对象引用为空
           
           转义序列：java中定义了一种特殊的标记来表示特殊字符，这种标记称为转义序列（由\后面加一个字符或一些数字位组成。一个转义序列被当做一个字符进                    行整体翻译）。
                  常用转义序列如下：
                     \b,退格键，Unicode码为\u0008
                     \t,Tab键，Unicode码为\u0009
                     \n,换行键，Unicode码为\u000A
                     \r,回车键，Unicode码为\u000D
                  有特殊含义的字符需要借助转义序列来表示，如 'java' 【'\'java\''】 "\"java\""【"java"】 \java【'\\java'】  
      运算符：
          算术运算符：+  -  *  /  %   a=1;b=++a;(a=2,b=2) a=1;b=a++;(a=2,b=1)  a=1;b=--a;(a=0;b=0)  a=1;b=a--;(a=0;b=1)
                 10/3【3】  10/0【除数不能为零报错】  10/3.0【3.3333333333333335】  10.0/0【infinity】  -10/0.0【-infinity】
                 5.5%3.2【2.3】   5%0.0【NaN】  -5%0.0【NaN】  0%5.0【0.0】 0%0.0【NaN】 5%0【除数不为零报错】 -5%3【-2】 5%-3【2】
          赋值运算符：=  +=  -=  *=  /=  %=    a+=1【a=a+1】 a*=2【a=a*2】
                 byte b=1； b=b+1【错误，常量1默认为int型，b+1为int型，需要强制转换】 b+=1【正确，自动完成强制类型转换】
          关系运算符：>  >=  <  <=  只支持数值类型比较；==  ！=  额外支持两个Boolean  或引用型的比较。
          逻辑运算符：&  |  ^  ! &&(短路与)  ||（短路或）   用于操作两个布尔型的变量，结果仍然是布尔型的。
                     ^异或表示两个操作数结果相同为false 两个操作数不同为true。
                     &&短路与表示当第一项为false时，第二项不再运算。
                     ||短路或表示当第一项为true时，第二项不再运算。
          位运算符：<<  >>  >>>,左移低位补0，右移低位截去，高位正数补0，负数补1。无符号右移（>>>）高位补0。只能操作整数类型的变量。对于低于int类型                    的（byte short char）操作数总是自动转化为int类型后再位移。对于位移数大于32时，先用位移数对32求余，【a>>1=a>>33】。对于long类                    型的位移，对64求余。
                   &  |  ^  ~(取反)负数的二进制表示为正数二进制按位取反后加1。理解byte的取值范围。
       程序的结构：
            顺序结构：
            选择结构：
               if（）{}  如果if的主体块只有一条语句，则可以省略左右大括号。【if else同样适用】
               if else   【max=x>y?x:y】
               if elseif elseif else
               switch(变量【byte、short、char、int、emun、String】){
                   case 常量1：{
                   语句；
                   break；
                   }
                   case 常量2：{
                   语句；
                   break；
                   }
                   default：{
                   语句；
                   }
               }如果匹配到满足条件后无break，将继续执行后续case中的内容。
            循环结构：
                while(){}当语句只有一条时候可以省略大括号。
                do{}while();结尾加；
                for(赋值初始；循环条件；迭代语句){
                   语句；
                }一条时可省略大括号【狗屁】
            循环中断：
                break：跳出当前循环进入下一步的执行【可以用lable标记，跳出被标记的循环】
                       lable：
                       for（）{
                          for(){
                           break lable;
                          }
                       }
                continue:结束当前循环（后面的语句不执行），进入下次循环。【可以用lable标记，跳出被标记的循环】
======================================================================================================================================
3、数组
       意义：为啥子要有数组尼，很简单，需要大量的同类型变量，显然一个一个去定义不现实，费时间。数组应用而生。
       数组特点：（1）只能存储同一种数据类型的数据。（2）数组一但定义好就不可以修改长度，因为数组在内存中所占的大小是固定的，因此数组灵活性较差。
       定义：数据类型[] 数组名   或   数据类型 数组名[]  推荐第一种，符合面向对象的思想。
       
       引用类型初始化：数组属于引用类型，数组初始化即让数组名指向数组对象的过程。
                     （1）数组对象的初始化，即为数组中元素分配内存空间和赋值。（2）数组名的初始化，将数组对象的引用赋值给数组名。
          静态初始化：int[] array=new int[]{1,2,3,4,5};程序员为数组的每个元素赋值，系统决定数组的长度。
          
                     int[] array;
                     array=new int[]{1,2,3,4,5};
                     
                     int[] array=new int[]{};
          动态初始化：int[] array=new int[10];程序员决定初始化数组的长度，系统为数组元素分配初始值（根据类型来定默认初始值）。
          java中各类型默认初始值：
          byte  0； short  0；  int  0；  long  0L；  float  0.0F；  double  0.0D；  char  '\u0000';   boolean  false;  引用数据类型 null
          数组下标越界异常：如果小标志小于0或者大于等于数组长度，编译不会报错，运行时将会出现异常，ArrayIndexOutOfBoundException:N,N表示试图访问                           的下标。
          数组的遍历：利用for循环中循环变量充当数组索引，递增索引，从而能遍历数组元素。
          数组的最值：利用第零位置的元素作为MAX OR MIN，依次遍历后续元素进行比较，将大值或小值放入MAX OR MIN中，即可求得。
          数组的排序：
          
          二维数组：
            动态初始化：int[][] array=new int[3][2];
                       array[0]={1,2};
                       array[1]={3,4};
                       array[2]={5,6};
            静态初始化：int[][] array=new int[][]{
                        {1},
                        {2,3},
                        {4}
                       }
                       int[][] array={
                        {1},
                        {2,3},
                        {4}
                       }
                    静态初始化数组长度由系统指定，不能手动指定。
               array.length：为一维数组个数；
               array[i].length：为一维数组包含元素的数量。
               锯齿数组（jaggedArray）:二维数组中包含长度不同的一维数组时，称为锯齿数组。
                    创建时可以指定第一个的下标，此时二维数组中的元素为空，因此还得为每个元素创建一维数组，如下：
                    动态初始化：int[][] x=new int[5][];
                               x[0]=new int[5];
                               x[1]=new int[4];
                               x[2]=new int[3];
                               x[3]=new int[2];
                               x[4]=new int[1];
4、方法：
       意义：多次重复使用相同的代码，编写维护比较麻烦，因此将此部分代码写成一个方法，以供程序反复调用。
       定义：修饰符  返回值类型  方法名（参数类型 参数1，参数类型 参数2）{
             方法体；
             return 返回值；
             }
       形参列表：指形参的类型、顺序、和数量。
       返回值：如果没有返回值，返回值类型为void，return可以省略。
       return：可用于终止方法（后面内容不再执行），返回到方法的调用者，控制程序的流程。
       传递过程：对于基本类型形参和实参是两个不同的存储单元，因此形参的改变不影响实参的值；对于引用数据类型，形参和实参存储的是引用（内存地址），都指                 向同一内存单元，因此方法执行过程中，形参的操作会影响实参。（引用类型在每个方法的操作过程中，都会改变并保留下来。）
       值传递（pass by value）：实参的值传递给方法的形参，方法内部对形参的修改不影响实参值。（方法执行结束后，系统将释放形参并将控制权返还给调用                                 者。）
       引用传递：实参的引用传递给方法的形参，方法内部形参操作的是实参指向的数据，会影响实参值。（执行结束，系统释放形参指向）
       方法执行过程（JVM）：每当调用一个方法时，JVM将会创建一个栈帧，用于保存该方法的形参和变量。当方法调用结束返回到调用者时，JVM释放相应的栈帧。每                           个方法从调用开始到执行完成的过程，就对应着一个栈帧在JVM中从入栈到出栈的过程。
       方法的重载（overloading）:是指方法名称相同，但形参列表不同的方法。调用重载方法时，java编译器会根据实参列表寻找最匹配（有些参数类型自动转换）                                 的方法进行调用。
          歧义调用（ambiguous invocation）： 调用方法时出现两个或多个可能的匹配，编译器无法判断哪个是最精确的匹配，则会产生编译错误。
          重载条件：只能根据参数列表（类型，顺序，个数）进行重载，不能通过修饰符和返回值进行重载。
       方法的递归：解决使用简单循环难以实现的问题。（必须有结束条件，否则会无限循环）
    ================================================================================================================================
   5、面向对象
      意义：将所有预处理的问题抽象为对象，实际上是对现实世界对象的建模。
      特点：
         封装性：将对象的属性和行为封装起来，载体就是类，通常对客户隐藏细节，这就是封装的思想。
         继承性：类与类之间的一种关系。
         多态性：多态性让子类可以扩展自己方法的同时，不同子类之间可以保持与父类同样的风格。
      类与对象：现实世界中事物就是对象，人类认识世界都渴望通过一种化繁为简的方式。于是认识事物分为两个部分，一个是静态部分即属性，是一个事物的自身固                有特点，一个是动态部分即行为，是一个事物可以做的动作。人类通过探讨对象的属性和行为来了解对象。 类是封装对象属性和行为的载体，对象是类                的一个实例化。
      类的定义:class 类名{属性1；属性2；方法1；}
      成员变量：类中的属性。作用域：整个类。
      局部变量：方法中变量和参数。作用域：当前方法。如果有与成员变量同名的优先访问局部变量。
      对象的创建：类是对象的抽象，本身不带任何数据，不存在与内存空间。对象是类的具体存在，拥有独立的内存空间。
                使用new来在堆内存中创建类的对象。"Person p"声明了一个Person类型的引用变量，"new Person()"为对象在堆内存中分配空间，最终返回对象的                 引用赋值给变量p。
                每次new都会开辟一个空间初始化一个对象。
      垃圾的产生：当对象不被任何变量引用时，就会成为垃圾，不能再被使用，等待垃圾回收机制进行回收。
      类的封装：通过Private成员变量，来隐藏内部的具体细节。只开放公共方法（可以过滤）访问，增加程序的安全性。
      构造方法：
           意义：用于类中属性的初始化。  
           定义：创建对象时，使用new关键字时被被调用的。（经测试其他时候无法被调用）
           特征：构造方法名与类名相同；构造方法没有返回值类型；构造方法中不能使用return返回一个值。
           构造方法存在：不进行定义时，系统会默认提供一个无参的构造方法。
                        进行定义后，系统将不提供缺省构造方法，因此每次定义构造方法前，先定义一个无参的构造方法，以免出错。
           重载：可以根据不同的初始化要求进行不同的重载。
      this关键字：
           意义：解决在成员方法中，因局部变量和成员变量名相同，而不能调用成员变量的问题。
           本质：表示当前对象，指向调用对象本身（对象的地址）。
           用法：（1）调用类中属性，避免成员变量与局部变量的冲突，而不能调用成员变量的问题。。
                （2）调用类中方法，代码清晰明确，即使类中方法间调用可以省略this。
                （3）调用构造方法，专用形式。this（构造方法实参），且该语句必须位于某个构造方法首行，且只能出现一次。
                     至少保留一个构造方法不适用this调用其他构造方法，避免出现递归构造器调用的编译错误。
      垃圾回收（Garbage Collection）：一种动态的存储管理技术。某对象失去引用时JVM会自动回收。
           申请垃圾回收：System.gc();
           内存释放时执行方法：java中所有类都可以重写object类中的finalize（）方法，该方法无返回值和参数，每个类有且只有一个该方法。
      static关键字：
           意义：用于修饰成员变量，成员方法以及代码块。
           静态变量：static修饰的成员变量，也叫类变量，被类的所有对象共享，可以直接通过类名访问当然也可以通过引用变量访问。
                    只能修饰成员变量，不能修饰局部变量，否则编译报错。
           静态方法：无需创建类的实例，可以直接通过类名调用。
                    静态方法只能访问类的静态成员，不能访问类的实例成员。因为未被static修饰的成员都是属于对象的，需要先创建对象，而静态方法在调用时                     可以不创建任何对象。
      代码块：指用“{}”括起来的一段代码，根据位置及关键字的不同，代码块可分为普通代码块、构造代码块、静态代码块、同步代码块。
           普通代码块：在方法名后或方法体中用“{}”括起来的一段代码。
                作用：限定变量的作用域。注意变量的使用前要声明。
           构造代码块：直接使用“{}”定义在类中的代码块，在创建对象时被调用。
                    作用：调用在构造方法之前，用来初始化成员变量。（将多个构造方法中重复的部分提取出来放在构造代码块中，提高代码的复用性。）
           静态代码块：使用static关键字修饰的代码块，是最早执行的代码块。
                作用：静态代码块优先于主方法和构造代码块执行，在java虚拟机加载类时候执行，无论实例被创建多少，只执行一次。
      内部类：类中除了可以定义成员变量和成员方法之外，还可以定义类，该类则称为内部类。
           内部类的共性特点：（1）内部类与外部类经java编译器编译后生产的两个类是独立的。（2）内部类是外部类的成员，因此能够访问外部类的任何成员（包                            括私有成员），但外部类不能直接访问内部类成员。（3）内部类可为静态，可用protected和private修饰，而外部类只能用public和                            默认的访问权限。
           成员内部类：类作为外部类的一个成员，能直接访问外部类的所有成员，但在外部类中访问内部类，则需要在外部类中创建内部类的对象，使用内部类的对                       象访问内部类的成员；若在外部类外访问内部类，则需要通过外部类对象创建内部类对象。
           
                      外部类外创建内部类对象的语法如下：
                      Other.Inner obj=new Other().new Inner();
                      Other.this.name 表示外部类的成员变量name  Other.this表示外部类对象。
                      注意：成员内部类不能定义静态变量、静态方法和静态内部类。当外部类加载时内部类不是静态的与java编译规则冲突。
           静态内部类：用static修饰的内部类称为静态内部类（如果不需要外部类对象与内部类对象有联系，则可如此声明）
                      
                      在内部类中通过 Other.name的方式访问外部类静态成员
                      在外部类中通过 Other.Inner.name的方式访问内部类的静态成员
                      Other.Inner obj=new Other.Inner();创建内部类对象来访问内部类实例
           方法内部类：指在成员方法中定义的类，与局部变量类似，作用域为定义它的代码块内。只能在定义它的方法内实例化。
                      
                      在方法体内定义类，可以访问外部类的成员。
                      在方法体内创建内部类对象：Inner obj=new Inner();
           匿名内部类：没有名称的内部类，只能使用一次。不加访问修饰符，常用来继承或接口的实现，定义后立即使用，且只使用一次。
                      
                      Person p=new Person(){
                       public void say(){
                         System.out.print(" 匿名内部类");
                       }
                      }
                      p.say();
6、类的继承
      意义：继承描述了类的所属关系，过个类通过继承形成关系体系。在原有类的基础上扩展新的功能，实现了代码的复用。
      继承：在已有类的基础上定义新的类，新的类能继承已有类的属性和行为，并扩展新的功能，不需要把已有类的内容再写一遍。已有的类被称为父类或基类，新的             类被称为子类或派生类。(子类继承父类所有成员，且可以扩展父类的功能)
            class Child extends Parent{}
            java不支持多继承，但是可以多重继承，及可以有爷爷辈。
      重写：子类重新定义从父类中继承的成员方法，这个过程称为方法的重写或覆盖。
           注意：被子类重写的方法不能拥有比父类更严格的访问权限。
           重写与重载的区别：
               方法重载：方法名相同，参数列表不同；
               方法重写：子类和父类中的方法，除了访问权限可以扩大外，其他均相同。
               方法重载是在同一个类中，方法重写是在子类与父类中。
      super关键字
          意义：当子类重写父类中的方法后，将无法访问父类中被重写的方法，子类中需要访问父类的被重写方法，通过super来实现。
          作用：调用父类的构造方法，与this关键字调用构造方法类似，该语句不需放到子类构造方法的第一行，否则编译出错。
               如果没有显示的调用父类的构造方法，那么将自动调用父类中不带参数的构造方法。所以子类没有显示调用父类中的指定构造方法时，必须保证父类中                存在无参的构造方法。）（类中会默认存在无参构造方法，但是重写后则会消失，所以重写前一定先写个无参构造方法）
          执行顺序：子类实例化时默认先调用父类的无参构造方法，所以父类的构造方法在子类的构造方法之前执行。
      final关键字
          意义：考虑安全因素，被它修饰的类、方法、变量不可修改。
              final修饰的类不可继承。
              final修饰的方法不能重写。
              final修饰的变量为常量，初始化后不能修改。
          修饰类：表示最终类，不能被其他类继承，如String类。     final class Parent{}
          修饰方法：表示最终方法，不能被子类重写。               public final void say(){}
          修饰变量：表示常量，只能被赋值一次。并且jvm不会为final修饰的变量默认初始化，所以记得声明后或者在构造方法中初始化。 final double PI=3.14;
          修饰引用变量：表示该变量只能始终引用一个对象。不能再被重新赋值。
      抽象类：
          抽象方法：java中可以定义不含方法体的方法，方法由子类根据实际需求去实现，这样的方法称为抽象方法。包含抽象方法的类一定是抽象类。
          抽象类：用abstract修饰的类，可以不包含任何抽象方法。
             注意：（1）抽象类不能被实例化，只能被子类继承实现。
                   （2）子类必须实现抽象父类中的所有抽象方法，否则子类必须声明为抽象类。
                   （3）抽象方法不能被static、final、private修饰，因为会发生类调用错误或子类不能继承重写。
                   （4）抽象类跟正常类一样，也有构造方法、成员变量等。
      接口：是全局常量和公共抽象方法的集合，是一种特殊的类，用interface修饰，被编译成独立字节码文件。
          定义：
           interface Parent{
               String name;         //等价于  public static final String name;
               void say();          //等价于  public abstract void say();
           }
          实现：
           class Child implements Person,Parent{}  实现接口最好实现它中的所有方法。接口存在的意义。
          继承：
           interface brother extends Person,parent{} 接口继承会获得父接口中所有的常量与抽象方法，而且接口支持多继承。
          注意：除了抽象类外，任何实现接口的类，必须实现所有的抽象方法，包括父类接口的抽象方法。
      抽象类和接口的关系：
          相同点：（1）都包含抽象方法。（2）都不能被实例化。（3）都是引用类型。
          不同点：（1）含义：接口描述的是一个类的外围能力而不是核心特征，类与接口之间是can do的关系；抽象类定义的是它的后代的核心特征派生类与抽                           象类之间是is a的关系。
                 （2）方法：接口只提供方法声明；抽象类可以提供完整的方法。默认构造方法，用于覆盖的方法声明。
                 （3）变量：接口只包含public static final常量，常量在声明时必须初始化；抽象类可以包含实例变量和静态变量。
                 （4）多重继承：接口可以继承多个接口；抽象类只能继承一个类。
                 （5）实现类：类可以实现多个接口；类只从抽象类中派生，必须重写。
                 （6）适用性：所有的实现只是共享方法签名；所有实现大同小异，并且共享状态和行为。
                 （7）简洁性：接口中常量默认为public static final，方法默认为public abstract；可以省略；子类实现的方法必须声明为abstract。
                 （8）添加功能：如果为接口添加新的方法，必须查找所有实现该接口的类，并注意提供该方法的实现；如果抽象类增加一个方法，可以直接实现，已                       存在的代码不需修改可以直接实现。
7、多态
        定义：指同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。封装和继承是为实现多态做准备的，简单讲，多态是具有表现多种形态能力的              特征，提高了程序的简洁性。java中多态是指把类中具有相似功能的不同方法使用同一个方法名实现，从而可以使用相同的方式来调用这些具有不同功                能的同名方法。
             概括讲就是变量引用的对象不同，执行结果也不同，这就是多态。体现在父类与子类同名方法和同一父类子类之间同名方法的执行结果不同。
        引用变量的类型：声明类型，变量声明时被指定的类型；实际类型，被变量引用的对象类型为实际类型。
        动态绑定：方法可以在沿着继承链的多个类中实现，当调用实例方法时，由JVM动态地决定所调用的方法，称为动态绑定。
            原理：调用实例方法时，JVM从该变量的实际类型开始，沿着继承链向上查找该方法的实现，直到找到为止，并调用首次找到的实现。
        对象类型转换：将一个对象的类型转换成继承结构中的另外一种类型。
            向上转型：从子类到父类的转换，也称为隐式转化。
            向下转型：从父类到子类的转化，也称为显示转化。
            注意：对象向下转型之后，调用的方法由实际对象决定。并且被转换变量的实际类型必须是转换类或其子类。
                 因为编译器检测的是变量的声明类型，向下转型可以通过编译。但运行时转换的是变量的实际类型不是子类或转换类就会报错。
        instanceof:用于判断一个对象是否是一个类（接口）或子类的实例。返回Boolean型值。
     Object类：
          意义：java中提供了一个Object类，是所有类的父类，如果一个类没有显示的指定继承类，则该类的父类默认为Object。
               如下两个类的定义等价：
                 class ClassName{}
                 class ClassName extends Object{}
          方法：
             toString():   toString()会返回一个描述该对象的字符串，由该对象的所属类名、@、对象十六进制形式的内存地址组成。
                                        直接打印对象会默认调用toString()方法。通常重写toString()方法返回对象的具体信息。
                                        同意方法有不同的执行结果，这是多态的体现。
             equals():     用于测试两个对象是否相等，默认使用==来判断两个引用变量是否指向同意对象，即地址是否相同。
                           如果要比较两个对象的内容是否相同，就需要重写equals（）方法。
                           
8、设计模式 
     定义：描述了软件设计过程中经常碰到的问题及解决方案，是面向对象经验设计的总结和理论化抽象。通过设计模式，开发者可以无数次重用已有的解决方案，无须            再重复相同的工作。
     单例模式：为了结局一个类在运行期间有且只有一个实例，并且自行实例化向整个系统提供这个实例。如Windows系统只提供一个任务管理器。
          特点：（1）单例模式的类只提供私有的构造方法。
                （2）类定义中含有一个该类的静态私有对象。
                （3）提供一个静态的公有方法用于创建或获取它本身的静态私有对象。
          实现：  
                 class Single{
                     private static Single INSTANCE=new Single();    //创建一个静态的私有对象
                     privata Single(){};                             //私有化构造方法
                     public static Single getInstance(){             //返回静态私有对象
                          return INSTANCE;
                     }
                }
                public class TestSingle{
                     public static void main(String[] args){
                          Single s1=Single.getInstance();
                          Single s2=Single.getInstance();
                          System.out.println(s1==s2);    //true
                    }
                }
      工厂模式（factory pattern）：主要用来实例化有共同接口的类，它可以动态决定应该实例化哪一个类，并且不必事先知道每次要实例化哪一个类。
          简单工厂（simple factory）：又称静态工厂，它的核心是类中包含一个静态方法，该方法用于根据参数来决定返回实现同一接口的不同类实例。
          工厂方法（factory method）：用多态削弱工厂类的职责，但产品太多时，每个产品对应一个工厂类，出现类爆炸。
          抽象工厂（abstract factory）：用于创建一系列相互关联或相互依赖的对象。抽象工厂是在工厂方法基础上进行了分类管理。
      代理设计（Proxy）：是指给某一个对象提供代理，由代理对象控制对原有对象的引用。代理操作调用真实操作。
   9、包
       意义：当声明的类很多时，类名就有可能冲突，这就需要一种机制来管理类名，因此java中引入了包机制。
       定义：是java中提供的一种区别类的名字空间的机制，是类的组织方式，是一组相关类和接口的集合，它提供了访问权限和命名的管理机制。
          package 包名
          注意：（1）包名中字母一般都要小写。
                （2）包的命名规则：将公司域名反转作为包名。
                （3）package语句必须是程序代码中的第一行可执行代码。
                （4）package语句最多只有一句。
       import语句：实际开发中要进行不同包的分类，不同包中的类进行相互调用时需要加包名，为了简化代码量，使用import。
            省略包名
            import  包名.类名  //导入单类
            import  包名.*     //导入包下的全部类
            省略类名
            import static  包名.类名.成员       //导入类指定静态成员
            import static  包名.类名.*          //导入该类全部静态成员
       java常用包：java.lang 核心包包括String/Math/System等，无须import手动导入，系统自动导入。
                  java.util 工具包，包含工具类、集合类等，如Arrays、List、和Set等
                  java.net  包含网络编程的类和接口
                  java.io   包含输入、输出编程的相关类和接口
                  java.text 包含格式化相关的类
                  java.sql  数据库操作包，提供各种数据库操作的类和接口
                  java.awt  包含抽象窗口工具集（abstract window toolkits）相关类和接口，用于构建图形用户界面（GUI）
                  java.swing  包含图形用户界面相关的类和接口
       jar包：全称(java archive file)java归档文件。
              将一个jar包添加到classpath环境变量中，JVM会自动解压jar包，根据包名所对应的目录结构去查找所需要的类。
